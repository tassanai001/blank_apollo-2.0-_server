"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var GraphQLExtension = /** @class */ (function () {
    function GraphQLExtension() {
    }
    return GraphQLExtension;
}());
exports.GraphQLExtension = GraphQLExtension;
var GraphQLExtensionStack = /** @class */ (function () {
    function GraphQLExtensionStack(extensions) {
        this.extensions = extensions;
    }
    GraphQLExtensionStack.prototype.requestDidStart = function (o) {
        return this.handleDidStart(function (ext) { return ext.requestDidStart && ext.requestDidStart(o); });
    };
    GraphQLExtensionStack.prototype.parsingDidStart = function (o) {
        return this.handleDidStart(function (ext) { return ext.parsingDidStart && ext.parsingDidStart(o); });
    };
    GraphQLExtensionStack.prototype.validationDidStart = function () {
        return this.handleDidStart(function (ext) { return ext.validationDidStart && ext.validationDidStart(); });
    };
    GraphQLExtensionStack.prototype.executionDidStart = function (o) {
        if (o.executionArgs.fieldResolver) {
            this.fieldResolver = o.executionArgs.fieldResolver;
        }
        return this.handleDidStart(function (ext) { return ext.executionDidStart && ext.executionDidStart(o); });
    };
    GraphQLExtensionStack.prototype.willSendResponse = function (o) {
        this.extensions.forEach(function (extension) {
            if (extension.willSendResponse) {
                extension.willSendResponse(o);
            }
        });
    };
    GraphQLExtensionStack.prototype.willResolveField = function (source, args, context, info) {
        var handlers = this.extensions
            .map(function (extension) {
            return extension.willResolveField &&
                extension.willResolveField(source, args, context, info);
        })
            .filter(function (x) { return x; })
            // Reverse list so that handlers "nest", like in handleDidStart.
            .reverse();
        return function (error, result) {
            for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {
                var handler = handlers_1[_i];
                handler(error, result);
            }
        };
    };
    GraphQLExtensionStack.prototype.format = function () {
        return this.extensions
            .map(function (extension) { return extension.format && extension.format(); })
            .filter(function (x) { return x; }).reduce(function (extensions, _a) {
            var key = _a[0], value = _a[1];
            return Object.assign(extensions, (_b = {}, _b[key] = value, _b));
            var _b;
        }, {});
    };
    GraphQLExtensionStack.prototype.handleDidStart = function (startInvoker) {
        var endHandlers = [];
        this.extensions.forEach(function (extension) {
            // Invoke the start handler, which may return an end handler.
            var endHandler = startInvoker(extension);
            if (endHandler) {
                endHandlers.push(endHandler);
            }
        });
        return function () {
            var errors = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                errors[_i] = arguments[_i];
            }
            // We run end handlers in reverse order of start handlers. That way, the
            // first handler in the stack "surrounds" the entire event's process
            // (helpful for tracing/reporting!)
            endHandlers.reverse();
            endHandlers.forEach(function (endHandler) { return endHandler.apply(void 0, errors); });
        };
    };
    return GraphQLExtensionStack;
}());
exports.GraphQLExtensionStack = GraphQLExtensionStack;
function enableGraphQLExtensions(schema) {
    if (schema._extensionsEnabled) {
        return schema;
    }
    schema._extensionsEnabled = true;
    forEachField(schema, wrapField);
    return schema;
}
exports.enableGraphQLExtensions = enableGraphQLExtensions;
function wrapField(field) {
    var fieldResolver = field.resolve;
    field.resolve = function (source, args, context, info) {
        var extensionStack = context && context._extensionStack;
        var handler = (extensionStack &&
            extensionStack.willResolveField(source, args, context, info)) ||
            (function (_err, _result) {
                /* do nothing */
            });
        // If no resolver has been defined for a field, use the default field resolver
        // (which matches the behavior of graphql-js when there is no explicit resolve function defined).
        try {
            var result = (fieldResolver ||
                (extensionStack && extensionStack.fieldResolver) ||
                graphql_1.defaultFieldResolver)(source, args, context, info);
            // Call the stack's handlers either immediately (if result is not a
            // Promise) or once the Promise is done. Then return that same
            // maybe-Promise value.
            whenResultIsFinished(result, handler);
            return result;
        }
        catch (error) {
            // Normally it's a bad sign to see an error both handled and
            // re-thrown. But it is useful to allow extensions to track errors while
            // still handling them in the normal GraphQL way.
            handler(error);
            throw error;
        }
    };
}
function isPromise(x) {
    return x && typeof x.then === 'function';
}
// Given result (which may be a Promise or an array some of whose elements are
// promises) Promises, set up 'callback' to be invoked when result is fully
// resolved.
function whenResultIsFinished(result, callback) {
    if (isPromise(result)) {
        result.then(function (r) { return callback(null, r); }, function (err) { return callback(err); });
    }
    else if (Array.isArray(result)) {
        if (result.some(isPromise)) {
            Promise.all(result).then(function (r) { return callback(null, r); }, function (err) { return callback(err); });
        }
        else {
            callback(null, result);
        }
    }
    else {
        callback(null, result);
    }
}
function forEachField(schema, fn) {
    var typeMap = schema.getTypeMap();
    Object.keys(typeMap).forEach(function (typeName) {
        var type = typeMap[typeName];
        if (!graphql_1.getNamedType(type).name.startsWith('__') &&
            type instanceof graphql_1.GraphQLObjectType) {
            var fields_1 = type.getFields();
            Object.keys(fields_1).forEach(function (fieldName) {
                var field = fields_1[fieldName];
                fn(field, typeName, fieldName);
            });
        }
    });
}
//# sourceMappingURL=index.js.map