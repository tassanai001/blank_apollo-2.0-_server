"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var url_1 = require("url"); // XXX use W3C URL instead for CloudFlare?
var graphql_1 = require("graphql");
var apollo_engine_reporting_protobuf_1 = require("apollo-engine-reporting-protobuf");
var signature_1 = require("./signature");
// EngineReportingExtension is the per-request GraphQLExtension which creates a
// trace (in protobuf Trace format) for a single request. When the request is
// done, it passes the Trace back to its associated EngineReportingAgent via the
// addTrace callback in its constructor. This class isn't for direct use; its
// constructor is a private API for communicating with EngineReportingAgent.
// Its public methods all implement the GraphQLExtension interface.
var EngineReportingExtension = /** @class */ (function () {
    function EngineReportingExtension(options, addTrace) {
        this.trace = new apollo_engine_reporting_protobuf_1.Trace();
        this.nodes = new Map();
        this.options = options;
        this.addTrace = addTrace;
        var root = new apollo_engine_reporting_protobuf_1.Trace.Node();
        this.trace.root = root;
        this.nodes.set(responsePathAsString(undefined), root);
    }
    EngineReportingExtension.prototype.requestDidStart = function (o) {
        var _this = this;
        this.trace.startTime = dateToTimestamp(new Date());
        this.startHrTime = process.hrtime();
        // Generally, we'll get queryString here and not parsedQuery; we only get
        // parsedQuery if you're using an OperationStore. In normal cases we'll get
        // our documentAST in the execution callback after it is parsed.
        this.queryString = o.queryString;
        this.documentAST = o.parsedQuery;
        var u = url_1.parse(o.request.url);
        this.trace.http = new apollo_engine_reporting_protobuf_1.Trace.HTTP({
            method: apollo_engine_reporting_protobuf_1.Trace.HTTP.Method[o.request.method] ||
                apollo_engine_reporting_protobuf_1.Trace.HTTP.Method.UNKNOWN,
            host: u.hostname,
            path: u.path,
        });
        if (this.options.privateHeaders !== true) {
            o.request.headers.forEach(function (value, key) {
                if (_this.options.privateHeaders &&
                    typeof _this.options.privateHeaders === 'object' &&
                    // We assume that most users only have a few private headers, or will
                    // just set privateHeaders to true; we can change this linear-time
                    // operation if it causes real performance issues.
                    _this.options.privateHeaders.includes(key.toLowerCase())) {
                    return;
                }
                switch (key) {
                    case 'authorization':
                    case 'cookie':
                    case 'set-cookie':
                        break;
                    default:
                        _this.trace.http.requestHeaders[key] = new apollo_engine_reporting_protobuf_1.Trace.HTTP.Values({
                            value: [value],
                        });
                }
            });
            if (o.persistedQueryHit) {
                this.trace.persistedQueryHit = true;
            }
            if (o.persistedQueryRegister) {
                this.trace.persistedQueryRegister = true;
            }
        }
        if (this.options.privateVariables !== true && o.variables) {
            // Note: we explicitly do *not* include the details.rawQuery field. The
            // Engine web app currently does nothing with this other than store it in
            // the database and offer it up via its GraphQL API, and sending it means
            // that using calculateSignature to hide sensitive data in the query
            // string is ineffective.
            this.trace.details = new apollo_engine_reporting_protobuf_1.Trace.Details();
            Object.keys(o.variables).forEach(function (name) {
                if (_this.options.privateVariables &&
                    typeof _this.options.privateVariables === 'object' &&
                    // We assume that most users will have only a few private variables,
                    // or will just set privateVariables to true; we can change this
                    // linear-time operation if it causes real performance issues.
                    _this.options.privateVariables.includes(name)) {
                    // Special case for private variables. Note that this is a different
                    // representation from a variable containing the empty string, as that
                    // will be sent as '""'.
                    _this.trace.details.variablesJson[name] = '';
                }
                else {
                    _this.trace.details.variablesJson[name] = JSON.stringify(o.variables[name]);
                }
            });
        }
        return function () {
            _this.trace.durationNs = durationHrTimeToNanos(process.hrtime(_this.startHrTime));
            _this.trace.endTime = dateToTimestamp(new Date());
            var operationName = _this.operationName || '';
            var signature;
            if (_this.documentAST) {
                var calculateSignature = _this.options.calculateSignature || signature_1.defaultSignature;
                signature = calculateSignature(_this.documentAST, operationName);
            }
            else if (_this.queryString) {
                // We didn't get an AST, possibly because of a parse failure. Let's just
                // use the full query string.
                //
                // XXX This does mean that even if you use a calculateSignature which
                //     hides literals, you might end up sending literals for queries
                //     that fail parsing or validation. Provide some way to mask them
                //     anyway?
                signature = _this.queryString;
            }
            else {
                // This shouldn't happen: one of those options must be passed to runQuery.
                throw new Error('No queryString or parsedQuery?');
            }
            _this.addTrace(signature, operationName, _this.trace);
        };
    };
    EngineReportingExtension.prototype.executionDidStart = function (o) {
        // If the operationName is explicitly provided, save it. If there's just one
        // named operation, the client doesn't have to provide it, but we still want
        // to know the operation name so that the server can identify the query by
        // it without having to parse a signature.
        //
        // Fortunately, in the non-error case, we can just pull this out of
        // the first call to willResolveField's `info` argument.  In an
        // error case (eg, the operationName isn't found, or there are more
        // than one operation and no specified operationName) it's OK to continue
        // to file this trace under the empty operationName.
        if (o.executionArgs.operationName) {
            this.operationName = o.executionArgs.operationName;
        }
        this.documentAST = o.executionArgs.document;
    };
    EngineReportingExtension.prototype.willResolveField = function (_source, _args, _context, info) {
        var _this = this;
        if (this.operationName === undefined) {
            this.operationName =
                (info.operation.name && info.operation.name.value) || '';
        }
        var path = info.path;
        var node = this.newNode(path);
        node.type = info.returnType.toString();
        node.parentType = info.parentType.toString();
        node.startTime = durationHrTimeToNanos(process.hrtime(this.startHrTime));
        return function () {
            node.endTime = durationHrTimeToNanos(process.hrtime(_this.startHrTime));
            // We could save the error into the trace here, but it won't have all
            // the information that graphql-js adds to it later, like 'locations'.
        };
    };
    EngineReportingExtension.prototype.willSendResponse = function (o) {
        var _this = this;
        var errors = o.graphqlResponse.errors;
        if (errors) {
            errors.forEach(function (error) {
                // By default, put errors on the root node.
                var node = _this.nodes.get('');
                if (error.path) {
                    var specificNode = _this.nodes.get(error.path.join('.'));
                    if (specificNode) {
                        node = specificNode;
                    }
                }
                node.error.push(new apollo_engine_reporting_protobuf_1.Trace.Error({
                    message: error.message,
                    location: (error.locations || []).map(function (_a) {
                        var line = _a.line, column = _a.column;
                        return new apollo_engine_reporting_protobuf_1.Trace.Location({ line: line, column: column });
                    }),
                    json: JSON.stringify(error),
                }));
            });
        }
    };
    EngineReportingExtension.prototype.newNode = function (path) {
        var node = new apollo_engine_reporting_protobuf_1.Trace.Node();
        var id = path.key;
        if (typeof id === 'number') {
            node.index = id;
        }
        else {
            node.fieldName = id;
        }
        this.nodes.set(responsePathAsString(path), node);
        var parentNode = this.ensureParentNode(path);
        parentNode.child.push(node);
        return node;
    };
    EngineReportingExtension.prototype.ensureParentNode = function (path) {
        var parentPath = responsePathAsString(path.prev);
        var parentNode = this.nodes.get(parentPath);
        if (parentNode) {
            return parentNode;
        }
        // Because we set up the root path in the constructor, we now know that
        // path.prev isn't undefined.
        return this.newNode(path.prev);
    };
    return EngineReportingExtension;
}());
exports.EngineReportingExtension = EngineReportingExtension;
// Helpers for producing traces.
// Convert from the linked-list ResponsePath format to a dot-joined
// string. Includes the full path (field names and array indices).
function responsePathAsString(p) {
    if (p === undefined) {
        return '';
    }
    return graphql_1.responsePathAsArray(p).join('.');
}
// Converts a JS Date into a Timestamp.
function dateToTimestamp(date) {
    var totalMillis = +date;
    var millis = totalMillis % 1000;
    return new apollo_engine_reporting_protobuf_1.google.protobuf.Timestamp({
        seconds: (totalMillis - millis) / 1000,
        nanos: millis * 1e6,
    });
}
// Converts an hrtime array (as returned from process.hrtime) to nanoseconds.
//
// ONLY CALL THIS ON VALUES REPRESENTING DELTAS, NOT ON THE RAW RETURN VALUE
// FROM process.hrtime() WITH NO ARGUMENTS.
//
// The entire point of the hrtime data structure is that the JavaScript Number
// type can't represent all int64 values without loss of precision:
// Number.MAX_SAFE_INTEGER nanoseconds is about 104 days. Calling this function
// on a duration that represents a value less than 104 days is fine. Calling
// this function on an absolute time (which is generally roughly time since
// system boot) is not a good idea.
//
// XXX We should probably use google.protobuf.Duration on the wire instead of
// ever trying to store durations in a single number.
function durationHrTimeToNanos(hrtime) {
    return hrtime[0] * 1e9 + hrtime[1];
}
//# sourceMappingURL=extension.js.map