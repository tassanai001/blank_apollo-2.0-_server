"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const CachePolicy = require("http-cache-semantics");
const apollo_server_caching_1 = require("apollo-server-caching");
class HTTPCache {
    constructor(keyValueCache = new apollo_server_caching_1.InMemoryLRUCache()) {
        this.keyValueCache = keyValueCache;
    }
    fetch(input, init) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = new Request(input, init);
            const cacheKey = cacheKeyFor(request);
            const entry = yield this.keyValueCache.get(cacheKey);
            if (!entry) {
                const response = yield fetch(request);
                const policy = new CachePolicy(policyRequestFrom(request), policyResponseFrom(response));
                return this.storeResponseAndReturnClone(request, response, policy);
            }
            const { policy: policyRaw, body } = JSON.parse(entry);
            const policy = CachePolicy.fromObject(policyRaw);
            if (policy.satisfiesWithoutRevalidation(policyRequestFrom(request))) {
                const headers = policy.responseHeaders();
                return new Response(body, { status: policy._status, headers });
            }
            else {
                const revalidationHeaders = policy.revalidationHeaders(policyRequestFrom(request));
                const revalidationRequest = new Request(request, {
                    headers: revalidationHeaders,
                });
                const revalidationResponse = yield fetch(revalidationRequest);
                const { policy: revalidatedPolicy, modified } = policy.revalidatedPolicy(policyRequestFrom(revalidationRequest), policyResponseFrom(revalidationResponse));
                return this.storeResponseAndReturnClone(revalidationRequest, modified
                    ? revalidationResponse
                    : new Response(body, {
                        status: revalidatedPolicy._status,
                        headers: revalidatedPolicy.responseHeaders(),
                    }), revalidatedPolicy);
            }
        });
    }
    storeResponseAndReturnClone(request, response, policy) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!response.headers.has('Cache-Control') || !policy.storable())
                return response;
            const cacheKey = cacheKeyFor(request);
            const body = yield response.text();
            const entry = JSON.stringify({ policy: policy.toObject(), body });
            let ttl = policy.timeToLive() / 1000;
            if (canBeRevalidated(response)) {
                ttl *= 2;
            }
            yield this.keyValueCache.set(cacheKey, entry, { ttl });
            return new Response(body, {
                status: response.status,
                statusText: response.statusText,
                headers: policy.responseHeaders(),
            });
        });
    }
}
exports.HTTPCache = HTTPCache;
function canBeRevalidated(response) {
    return response.headers.has('ETag');
}
function cacheKeyFor(request) {
    return `httpcache:${request.url}`;
}
function policyRequestFrom(request) {
    return {
        url: request.url,
        method: request.method,
        headers: headersToObject(request.headers),
    };
}
function policyResponseFrom(response) {
    return {
        status: response.status,
        headers: headersToObject(response.headers),
    };
}
function headersToObject(headers) {
    const object = Object.create(null);
    for (const [name, value] of headers) {
        object[name] = value;
    }
    return object;
}
//# sourceMappingURL=HTTPCache.js.map